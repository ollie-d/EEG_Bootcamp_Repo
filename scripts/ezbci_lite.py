'''EEG processing functions for BrainE data

Functions for EEG processing
Partially harvested from school projects and my library ezbci

Created : 
    [27Feb2021] Alessandro "Ollie" D'Amico (ollie-d)
Last Modified : 
    [06Feb2022] Alessandro "Ollie" D'Amico (ollie-d)
'''

import numpy as np
from scipy import signal
from pathlib import Path
import glob
import pandas as pd
import os
import copy
import pyxdf
from itertools import chain
import matplotlib.pyplot as plt
import matplotlib.patches as patches

def listFlatten(l):
    return list(chain.from_iterable(l))

def loadxdf(fname, synthetic = False):
    """Loads an XDF containing an EEG stream and marker stream

    Args:
        fname (str): Full file location of the XDF
        synthetic (bool): Whether or not the file is a synthetic example (appends channels, zero-pads EEG data)
        
    Returns:
        dict: Creates an EEG structure as a dict containing:
            eeg_data: Time series EEG data
            eeg_time: Time points corresponding to EEG data
            event_data: Marker data (asynchronous)
            event_time: Time points corresponding to marker onset
            channels: Electrode locations as a dict
            fs: Sampling rate of EEG data
            fs_i: Initial sampling rate of EEG data (will not change when resampling)
            
    Unit Test:
        None
        
    TODO:
        Have this function handle aux stream as well for accelerometer on Cyton
        
    Last Modified:
        Ollie 15Feb22
    """
    # Load dataset from xdf and export eeg_raw, eeg_time, mrk_raw, mrk_time, channels
    streams, fileheader = pyxdf.load_xdf(fname, dejitter_timestamps=False) #ollie 9/11/2019
    
    # Create empty dict to be returned
    EEG = {}
    
    # Boolean variable for lack of marker stream
    has_marker = True # true by default
    
    # Seperate streams
    eeg = None;
    mrk = None;
    for stream in streams:
        stream_type = stream['info']['type'][0]
        if stream_type.lower() == 'markers':
            mrk = stream
        if stream_type.lower() == 'eeg':
            eeg = stream
    if (eeg == None) and (mrk == None):
        print('ERROR, EEG AND MARKER STREAM NOT FOUND!')
        return
        
    if eeg != None and mrk == None:
        has_marker = False
        print('Warning: No marker stream found.')
    
    if synthetic:
        # Load channel data in
        with open ('xdf_channels', 'rb') as fp:
            xdf_channels = pickle.load(fp)
        eeg['info']['desc'] = xdf_channels
        
    # Create channel structure from stream info
    channel = {}
    try:
        desc = eeg['info']['desc'][0]['channels'][0]['channel']
        for i in range(int(eeg['info']['channel_count'][0])):
            channel[desc[i]['label'][0]] = i
    except:
        print('Warning: channel ingormation not found.')
            
    
    
    
    # Populate EEG with data
    eeg_time = eeg['time_stamps']
    EEG['eeg_data'] = eeg['time_series']
    EEG['eeg_time'] = eeg['time_stamps']
    EEG['channels'] = channel
    EEG['fs'] = int(eeg['info']['nominal_srate'][0])
    EEG['fs_i'] = int(eeg['info']['nominal_srate'][0]) # Note: This is a constant
    if has_marker:
        mrk_time = mrk['time_stamps']
        EEG['event_data'] = np.array(listFlatten(mrk['time_series']))
        EEG['event_time'] = mrk['time_stamps']

    # If synthetic, pad data with ending 0's
    if synthetic:
        EEG['eeg_data'] = np.vstack((EEG['eeg_data'], np.zeros((10000, int(eeg['info']['channel_count'][0])))))

    # Clear un-needed objects
    streams = None
    fileheader = None
    eeg = None
    mrk = None
    desc = None
    channel = None
    
    return EEG

def filt_cont(EEG, coeffs, order, btype='bandpass', style='fir', causal=True):
    '''Filter continuous data
    
    This supports Butterworth (IIR) and firwin (FIR) filtering.
    For FIR filter, order == numtaps
    
    Parameters
    ----------
        EEG : dict
            Dict containing all relevant data (generated by 'loadxdf')
        coeffs : list
            List containing filter coefficients. If bandpass/bandstop
            list must have 2 elements. Not checked, but an exception
            will be raised if this is not true by scipy functions.
        order : int
            Filter order. For IIR this is standard order, for FIR this
            must be an odd number and is equal to numtaps. If the number
            is even, the function will correct it by adding 1.
        btype : str, optional
            Type of filter which scipy will understand. Valid inputs would be
            bandpass (default), lowpass, highpass, bandstop
        style : str, optional
            Style of filter, IIR (default) or FIR.
        causal : bool, optional
            Whether to filter causally or non-causal (default)
            
    Returns
    -------
        eeg_df_ : dict
            Dict containing all relevant data, but filtered
            
     Notes
    -----
        Created : 
            [27Feb2021] Alessandro "Ollie" D'Amico (ollie-d)
        Last Modified : 
            [04Feb2022] Alessandro "Ollie" D'Amico (ollie-d)
    '''
    
    eeg_df_ = copy.deepcopy(EEG)
    eeg = eeg_df_['eeg_data']
    fs = eeg_df_['fs']
    filt = None
    
    if style.lower() == 'iir':
        sos = signal.butter(order, coeffs, btype, fs=fs, output='sos')
        if causal:
            print('Causal IIR Warning: Non-linear phase delay introduced.')
            filt = signal.sosfilt(sos, eeg, axis=0)
        else:
            filt = signal.sosfiltfilt(sos, eeg, axis=0)
    elif style.lower() == 'fir':
        if (order % 2) == 0:
            order += 1
        b = signal.firwin(numtaps=order, cutoff=coeffs, pass_zero=btype, fs=fs)
        a = 1
        if causal:
            print('Causal FIR Warning: Linear phase delay introduced.')
            filt = signal.lfilter(b, a, eeg, axis=0)
        else:
            filt = signal.filtfilt(b, a, eeg, axis=0)
    else:
        raise Exception('Unknown filter style. Only IIR and FIR supported.')
        
    eeg_df_['eeg_data'] = filt
    eeg  = None
    filt = None
    b    = None
    a    = None
    sos  = None
    
    return eeg_df_
        
def epoch(EEG, marker, start, end, chunk_start = None, chunk_end = None):
    '''Epoch continuous EEG data
    
    This function will epoch the data using 'EEG' and can epoch within chunks.
    Epoching within chunks may be useful.
    
    The function will ensure that it takes full epochs.
    This means that if an epoch's end as defined by 'end' goes beyond the chunk_end
    time, it will still epoch the full ERP. Currently this means that if an ERP starts
    even one microsecond before 'chunk_end' it will be included. This behavior can be
    modified if needed.

    Parameters
    ----------
        EEG : dict
            Dict containing all relevant data (generated by 'loadxdf')
        marker : str
            The marker which will be searched for epoching
        start : float
            The start of the epoch (in ms), locked to marker onset
        end : float
            The end of the epoch (in ms), locked to marker onset
        chunk_start : str, optional
            The first marker to epoch within
        chunk_end : str, optional
            The last marker to epoch within

    Returns
    -------
        erp_df : dict
            Dict containing ERP data and times
            erp_data : numpy.ndarray
                3D (erp_num x epoch_len x num_channel) array of ERPs
            erp_time : numpy.ndarray
                1D array of ERP times (epoch_len)

    Notes
    -----
        Created : 
            [27Feb2021] Alessandro "Ollie" D'Amico (ollie-d)
        Last Modified : 
            [04Feb2022] Alessandro "Ollie" D'Amico (ollie-d)
    '''
    
    # The first thing we'll do is align the marker times with EEG times
    mrks_t = np.zeros_like(EEG['event_time'])
    mrks   = copy.deepcopy(EEG['event_data'])
    for i in range(len(EEG['event_time'])):
        mrk = EEG['event_time'][i]
        mrks_t[i] = EEG['eeg_time'][np.argmin(np.abs(EEG['eeg_time']-mrk))]
    
    # If chunk_start is defined, crop markers from start
    if chunk_start != None:
        s = np.where(mrks == str(chunk_start))[0]
        if len(s) > 0:
            s = s[0]
            
            # Verify we have enough room for first epoch
            if (mrks_t[s] + (start / 1000)) < np.min(EEG['eeg_time']):
                raise Exception('First epoch starts before EEG signals begin')
            
            mrks_t = mrks_t[s:]
            mrks   = mrks[s:]
        else:
            raise Exception('chunk_start error: No marker %s found in EEG.' % (str(chunk_start)))
            
    # If chunk_end is defined, crop markers to end
    if chunk_end != None:
        e = np.where(mrks == str(chunk_end))[0]
        if len(e) > 0:
            e = e[0]
            
            # Verify we have enough room for final epoch
            if (mrks_t[e] + (end / 1000)) > np.max(EEG['eeg_time']):
                raise Exception('Final epoch ends after EEG signals end')
            
            mrks_t = mrks_t[0:e]
            mrks   = mrks[0:e]
        else:
            raise Exception('chunk_end error: No marker %s found in EEG.' % (str(chunk_end)))
            
    # We are now ready to epoch. Let's define epoch start and end in index space
    s_ix = np.round(start / (1000/EEG['fs'])).astype(int)
    e_ix = np.round(end   / (1000/EEG['fs'])).astype(int)
    
    # Now we can locate all indices where our marker exists in 'eeg_time'
    onsets = mrks_t[np.where(mrks == marker)]
    onsets_ix = np.searchsorted(EEG['eeg_time'], onsets)
    
    # Create a 3D array to store our results and iterate through onsets_ix to epoch
    erp = np.zeros((len(onsets_ix), e_ix - s_ix, EEG['eeg_data'].shape[1]))
    for i in range(len(onsets_ix)):
        t0 = onsets_ix[i]
        erp[i, :, :] = EEG['eeg_data'][s_ix+t0:t0+e_ix, :]
        
    # Generate times and an ERP dict to return
    ERP =   {'erp_data': erp,
              'erp_time': np.arange(start, end, (1000/EEG['fs']))}
    
    # Clear memory
    mrks_t    = None
    mrks      = None
    s         = None
    e         = None
    s_ix      = None
    e_ix      = None
    onsets    = None
    onsets_ix = None
    t0        = None
    i         = None
    
    return ERP

def baseline_correct(ERP, bl_s, bl_e):
    ''' Baseline correct epoched data
    
    Does everything in a single subtraction, avoiding loops at the cost of memory
    
    Made this quickly so excuse  the poor comments
    
    Created : 
        [06Feb2022] Alessandro "Ollie" D'Amico (ollie-d)
    Last Modified : 
        [06Feb2022] Alessandro "Ollie" D'Amico (ollie-d)
    '''
    ERP_ = copy.deepcopy(ERP)

    nepochs, ntimes, nchans = ERP_['erp_data'].shape

    # Compute baseline for every epoch/channel
    bl_s_ix = np.where(ERP_['erp_time'] == bl_s)[0][0]
    bl_e_ix = np.where(ERP_['erp_time'] == bl_e)[0][0]
    bl_2D = np.mean(ERP_['erp_data'][:, bl_s_ix:bl_e_ix, :], axis=1)
    bl_3D = np.transpose(np.repeat(bl_2D, ntimes).reshape(nepochs, nchans, ntimes), (0, 2, 1))

    # Subtract from signal
    ERP_['erp_data'] = np.subtract(ERP_['erp_data'], bl_3D)
    
    # Clear memory
    bl_s_ix = None
    bl_e_ix = None
    bl_2D = None
    bl_3D = None
    
    return ERP_
